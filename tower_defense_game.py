# -*- coding: utf-8 -*-
"""Tower Defense Game

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13084sIgsHCvT8c0NeLkgu2w82NfqmhiR
"""

from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import math
import random
from screeninfo import get_monitors


tower_x = 0  # Center of the screen
tower_y = 0  # Center of the screen
tower_width = 20
tower_height = 40
tower_radius = 10
tower_health = 100


def midpointCircle(tower_x, tower_y, radius):
    x = 0
    y = radius
    var = 1 - radius
    drawCirclePoints(tower_x, tower_y, x, y)
    while x < y:
        x += 1
        if var < 0:
            var = var + 2 * x + 1
        else:
            y -= 1
            var = var + 2 * x - 2 * y + 1

        drawCirclePoints(tower_x, tower_y, x, y)

def draw_point(x, y):
    glPointSize(3.0)
    glBegin(GL_POINTS)
    glVertex2f(x, y)
    glEnd()

def findzone(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1

    if abs(dx) > abs(dy):
        if dx >= 0 and dy >= 0:
            return 0
        elif dx >= 0 and dy < 0:
            return 7
        elif dx < 0 and dy >= 0:
            return 3
        elif dx < 0 and dy < 0:
            return 4
    else:
        if dx >= 0 and dy >= 0:
            return 1
        elif dx >= 0 and dy < 0:
            return 6
        elif dx < 0 and dy >= 0:
            return 2
        elif dx < 0 and dy < 0:
            return 5

def convertZone0(zone, x, y):
    if zone == 0:
        return x, y
    elif zone == 1:
        return y, x
    elif zone == 2:
        return y, -x
    elif zone == 3:
        return -x, y
    elif zone == 4:
        return -x, -y
    elif zone == 5:
        return -y, -x
    elif zone == 6:
        return -y, x
    elif zone == 7:
        return x, -y


def orgZone(zone, x, y):
    if zone == 0:
        return x, y
    elif zone == 1:
        return y, x
    elif zone == 2:
        return -y, x
    elif zone == 3:
        return -x, y
    elif zone == 4:
        return -x, -y
    elif zone == 5:
        return -y, -x
    elif zone == 6:
        return y, -x
    elif zone == 7:
        return x, -y

def midpoint_line(zone, x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    d = 2 * dy - dx
    dNE = 2 * (dy - dx)
    dE = 2 * dy

    x, y = x1, y1

    while x <= x2:
        cx, cy = orgZone(zone, x, y)
        draw_point(cx, cy)
        if d <= 0:
            x += 1
            d += dE
        else:
            x += 1
            y += 1
            d += dNE
def midpoint_line_8way(x1, y1, x2, y2):
    zone = findzone(x1, y1, x2, y2)
    x1, y1 = convertZone0(zone, x1, y1)
    x2, y2 = convertZone0(zone, x2, y2)
    midpoint_line(zone, x1, y1, x2, y2)

def drawCirclePoints(xc, yc, x, y):

        draw_point(xc + x, yc + y)
        draw_point(xc - x, yc + y)
        draw_point(xc + x, yc - y)
        draw_point(xc - x, yc - y)
        draw_point(xc + y, yc + x)
        draw_point(xc - y, yc + x)
        draw_point(xc + y, yc - x)
        draw_point(xc - y, yc - x)

def draw_rectangle(x1, y1, x2, y2):
    midpoint_line_8way(x1, y1, x2, y1)
    midpoint_line_8way(x2, y1, x2, y2)
    midpoint_line_8way(x2, y2, x1, y2)
    midpoint_line_8way(x1, y2, x1, y1)

def draw_arrow(x, y, angle, length=20):
    x_end = x + length * math.cos(angle)
    y_end = y + length * math.sin(angle)
    midpoint_line_8way(round(x), round(y), round(x_end), round(y_end))

    # Draw the arrowhead
    head_angle1 = angle - math.pi / 6
    head_angle2 = angle + math.pi / 6
    head_length = 5

    head_x1 = x_end - head_length * math.cos(head_angle1)
    head_y1 = y_end - head_length * math.sin(head_angle1)
    head_x2 = x_end - head_length * math.cos(head_angle2)
    head_y2 = y_end - head_length * math.sin(head_angle2)

    midpoint_line_8way(round(x_end), round(y_end), round(head_x1), round(head_y1))
    midpoint_line_8way(round(x_end), round(y_end), round(head_x2), round(head_y2))

def draw_hexagon(x, y, size):
    for i in range(6):
        angle1 = 2 * math.pi * i / 6
        angle2 = 2 * math.pi * (i + 1) / 6
        x1 = x + size * math.cos(angle1)
        y1 = y + size * math.sin(angle1)
        x2 = x + size * math.cos(angle2)
        y2 = y + size * math.sin(angle2)
        midpoint_line_8way(round(x1), round(y1), round(x2), round(y2))

def draw_text(x, y, text, size=GLUT_BITMAP_HELVETICA_18):
    glRasterPos2f(x, y)
    for char in text:
        glutBitmapCharacter(size, ord(char))

# Game class
class TowerDefenseGame:
    def __init__(self):
        self.tower_x = 0  # Center of the screen
        self.tower_y = 0  # Center of the screen
        self.tower_width = 20
        self.tower_height = 40
        self.tower_radius = 10
        self.max_health = 30
        self.tower_health=self.max_health
        self.projectiles = []
        self.tower_range_radius = 30
        self.enemies = []
        self.score = 0
        self.spawn_timer = 0
        self.arrow_angle = 0
        self.missed_targets = 0
        self.enemies_entered = 0
        self.pause=False
    def draw_tower(self):
        glColor3f(0.5, 0.25, 0.0)
        draw_rectangle(self.tower_x - self.tower_width // 2, self.tower_y - self.tower_height // 2,
                       self.tower_x + self.tower_width // 2, self.tower_y + self.tower_height // 2)
        glColor3f(0.6, 0.4, 0.2)
        midpointCircle(self.tower_x, self.tower_y + self.tower_height // 2 + 5, self.tower_radius)
        glColor3f(0.0, 0.0, 0.0)
        midpointCircle(self.tower_x, self.tower_y + self.tower_height // 2 + 5, self.tower_radius - 2)

        glColor3f(0.0, 0.5, 0.0)  # Green color for the range
        midpointCircle(self.tower_x, self.tower_y, self.tower_range_radius)

    def draw_health_bar(self):
        bar_width = 40
        bar_height = 5
        health_percentage = self.tower_health / self.max_health

        # Background (gray bar)
        glColor3f(0.5, 0.5, 0.5)
        draw_rectangle(-bar_width // 2, 90, bar_width // 2, 90 + bar_height)

        # Foreground (green bar representing health)
        glColor3f(0.0, 1.0, 0.0)
        draw_rectangle(-bar_width // 2, 90,
                       -bar_width // 2 + int(bar_width * health_percentage), 90 + bar_height)

    def draw_arrow(self):
        glColor3f(1.0, 1.0, 0.0)
        draw_arrow(self.tower_x, self.tower_y + self.tower_height // 2 + 5, self.arrow_angle)

    def draw_projectiles(self):
        glColor3f(1.0, 1.0, 0.0)
        for proj in self.projectiles:
            midpointCircle(proj['x'], proj['y'], 2)

    def draw_enemies(self):
        for enemy in self.enemies:
            glColor3f(enemy['color'][0], enemy['color'][1], enemy['color'][2])
            draw_hexagon(enemy['x'], enemy['y'], 6)

    def spawn_enemy(self):
        side = random.choice(['left', 'right', 'top'])
        if side == 'left':
            x, y = -100, random.uniform(-90, 90)
        elif side == 'right':
            x, y = 100, random.uniform(-90, 90)
        elif side == 'top':
            x, y = random.uniform(-90, 90), 100

        direction_x = self.tower_x - x
        direction_y = self.tower_y - y
        length = math.sqrt(direction_x**2 + direction_y**2)
        speed = random.uniform(0.5, 1.5)

        self.enemies.append({
            'x': x,
            'y': y,
            'speed_x': speed * (direction_x / length),
            'speed_y': speed * (direction_y / length),
            'color': (random.random(), random.random(), random.random())
        })

    def update_projectiles(self):
        for proj in self.projectiles[:]:
            proj['x'] += 3 * math.cos(proj['angle'])
            proj['y'] += 3 * math.sin(proj['angle'])
            if proj['x'] < -100 or proj['x'] > 100 or proj['y'] < -100 or proj['y'] > 100:
                self.projectiles.remove(proj)
                self.missed_targets += 1

    def update_enemies(self):
        if self.spawn_timer <= 0:
            self.spawn_enemy()
            self.spawn_timer = 50
        else:
            self.spawn_timer -= 1

        for enemy in self.enemies[:]:
            enemy['x'] += enemy['speed_x']
            enemy['y'] += enemy['speed_y']

            # Check if the enemy crosses the tower's range
            distance_squared = (enemy['x'] - self.tower_x) ** 2 + (enemy['y'] - self.tower_y) ** 2
            #if distance_squared < self.tower_radius ** 2:
                # Enemy reaches the tower
                #self.enemies.remove(enemy)
                #self.enemies_entered += 1
            if distance_squared < self.tower_range_radius ** 2:
                # Enemy crosses the range
                self.enemies.remove(enemy)
                self.enemies_entered += 1
                self.tower_health -= 10  # Reduce health by 10

    def shoot(self):
        self.projectiles.append({
            'x': self.tower_x,
            'y': self.tower_y + self.tower_height // 2 + 5,
            'angle': self.arrow_angle
        })

    def check_hits(self):
        for proj in self.projectiles[:]:
            for enemy in self.enemies[:]:
                if (proj['x'] - enemy['x'])**2 + (proj['y'] - enemy['y'])**2 < 5**2:
                    self.projectiles.remove(proj)
                    self.enemies.remove(enemy)
                    self.score += 10

    def display_ui(self):
        glColor3f(1.0, 1.0, 1.0)
        draw_text(-95, 90, f"Score: {self.score}")
        draw_text(-95, 80, f"Missed: {self.missed_targets}")
        draw_text(-95, 70, f"Entered: {self.enemies_entered}")
        self.draw_health_bar()
    def display(self):
        glClear(GL_COLOR_BUFFER_BIT)
        self.draw_tower()
        self.draw_arrow()
        self.draw_projectiles()
        self.draw_enemies()
        self.display_ui()

        if self.pause:
            glColor3f(1.0, 1.0, 1.0)
            draw_text(-20, 0, "PAUSED")


        elif self.enemies_entered >= 3:
            draw_text(-20, 0, "GAME OVER: Enemies Entered")
        #elif self.missed_targets >= 4:
            #draw_text(-20, 0, "GAME OVER: Missed Targets")
        elif self.enemies_entered >= 3 or self.tower_health <= 0:
            draw_text(-20, 0, "GAME OVER: Tower Destroyed")
        glFlush()

    def update(self, value):
        if self.pause:
            glutTimerFunc(50, self.update, 0)
            return

        if self.enemies_entered < 3: #and self.missed_targets < 4:
            self.update_projectiles()
            self.update_enemies()
            self.check_hits()
            glutPostRedisplay()
            glutTimerFunc(50, self.update, 0)

    def mouse_motion(self, x, y):
        screen_width, screen_height = glutGet(GLUT_WINDOW_WIDTH), glutGet(GLUT_WINDOW_HEIGHT)
        x = (x / screen_width) * 200 - 100
        y = 100 - (y / screen_height) * 200
        self.arrow_angle = math.atan2(y - (self.tower_y + self.tower_height // 2 + 5), x - self.tower_x)

    def mouse_click(self, button, state, x, y):
        if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:
            self.shoot()
    def restart(self):
        self.tower_health = self.max_health
        self.projectiles = []
        self.enemies = []
        self.score = 0
        self.spawn_timer = 0
        self.missed_targets = 0
        self.enemies_entered = 0
        self.pause = False
        glutPostRedisplay()

    def key_press(self, key, x, y):
        if key == b'p':  # Toggle pause
            self.pause = not self.pause
            glutPostRedisplay()
        elif key == b'r':  # Restart game
            self.restart()



def main():
    monitor = get_monitors()[0]
    screen_width = monitor.width
    screen_height = monitor.height - 120

    game = TowerDefenseGame()

    glutInit()
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB)
    glutInitWindowSize(screen_width, screen_height)
    glutInitWindowPosition(0, 0)
    glutCreateWindow(b"Tower Defense Game")
    glClearColor(0.0, 0.0, 0.0, 0.0)
    gluOrtho2D(-100, 100, -100, 100)
    glutDisplayFunc(game.display)
    glutPassiveMotionFunc(game.mouse_motion)
    glutMouseFunc(game.mouse_click)
    glutKeyboardFunc(game.key_press)
    glutTimerFunc(50, game.update, 0)
    glutMainLoop()

if __name__ == "__main__":
    main()